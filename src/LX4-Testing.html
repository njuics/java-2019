<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>测试 Testing</title>
</head>

<body>

    <div class="reveal">
        <div class="slides">

            <section class="title-slide">
                <div class="huge framed bordered border-3x font-passionone bg-warning-alpha-08">
                    测试 Testing
                </div>
            </section>


            <section>
                <div class="down-3">
                    <h2>软件测试</h2>
                </div>
                <div class="down-9">

                    “使用人工和自动手段来运行或测试某个系统的过程，其目的在于检验它是否满足规定的需求或弄清楚预期结果与实际结果之间的差别。”
                </div>

                <div class="down-3">在软件开发中是一个很重要的方面，良好的测试可以在很大程度决定一个应用的命运。
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>测试金字塔模型</h2>
                </div>
                <div class="down-3">
                    <img
                        src="https://res.infoq.com/news/2017/10/micro-service-build-test-culture/zh/resources/851-1509263405983.png" />
                </div>
            </section>

            <section>

                <div class="down-3">
                    <h2>测试过程</h2>
                </div>
                <div class="down-1 center">
                    <div class="center down-1">
                        <img width="80%"
                            src="https://res.infoq.com/news/2017/10/micro-service-build-test-culture/zh/resources/492-1509263405982.png" />
                    </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>单元测试</h2>
                </div>
                <div class="down-9">

                    单元测试中的“单元”在Java中可以理解为某个类中的某一个方法，因此“单元测试”就是针对Java中某个类中的某一个方法中的逻辑代码进行验证即测试该方法是不是可以正常工作。 </div>

            </section>

            <section>
                <div class="down-3">
                    <h2>为什么需要进行单元测试</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li class="down-3 big">
                            单元测试的测试相对于集成测试的测试成本较低
                        </li>
                        <li class="down-3 big">
                            提高开发效率 </li>
                        <li class="down-3 big">
                            提升项目工程代码质量 </li>
                        <li class="down-3 big">
                            快速定位Bug
                        </li>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>测试工具（框架）</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li class="down-3 big">
                            JUnit
                        </li>
                        <li class="down-3 big">
                            TestNG </li>
                        <li class="down-3 big">
                            Spock </li>
                        <li class="down-3 big">
                            ...
                        </li>
                    </ul>
                </div>
                <div class="down-5 small center">
                    测试本身不是Java语言层面的内容
                </div>
            </section>


            <section>
                <div class="down-20 center larger">
                    Junit </div>
                <div class="down-9 small center">
                    <a
                        href="https://github.com/junit-team/junit4/wiki/Download-and-Install">https://github.com/junit-team/junit4/wiki/Download-and-Install</a>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>简单实例</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                public class Math {
                                    /**
                                     * 阶乘
                                     * @param n
                                     * @return
                                     */
                                    public int factorial(int n) throws Exception {
                                        if (n < 0) {
                                            throw new Exception("负数没有阶乘");
                                        } else if (n <= 1) {
                                            return 1;
                                        } else {
                                            return n * factorial(n - 1);
                                        }
                                    }
                                
                                }
                        </code>
                        
                    </pre>
                </div>
                <div class="center">
                    如何验证<code>factorial()</code>是对的？

                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>编写一个“测试类”</h2>
                </div>
                <div class="row down-3">
                    <div class="col-50">
                        <pre class="java">
                                        <code data-trim>
                                                import org.junit.Test;
                                                import static org.junit.Assert.*;
                                                
                                                public class MathTest {
                                                    @Test
                                                    public void testFactorial() throws Exception {
                                                        assertEquals(120, new Math().factorial(5));
                                                    }
                                                }
                                        </code>
                                        
                                    </pre>
                    </div>
                    <div class="col-50">
                        <ul>
                            <li>
                                导入了<code>org.junit.Test</code>和<code>org.junit.Assert.*</code>，后者是静态导入
                            </li>
                            <li>
                                <code>testFactorial</code>是在要测试的方法名<code>factorial</code>前加个<code>test</code>
                            </li>
                            <li>
                                所有测试方法返回类型必须为<code>void</code>且无参数。
                            </li>
                            <li>
                                一个测试方法之所以是个测试方法是因为<code>@Test</code>这个注解
                            </li>
                            <li>
                                <code>assertEquals</code>的作用是判断两个参数是否相等
                            </li>
                            <li>
                                JUnit4包含一堆<code>assertXX</code>方法，这些<code>assertXX</code>统称为断言
                            </li>
                        </ul>

                    </div>
                </div>

            </section>

            <section>
                <div class="down-3">
                    <h2>在IDE中写测试用例</h2>
                </div>
                <div class="down-9">
                    Keeps the bar <span class="success">green</span> to keep the code clean.

                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>使用注解来定义测试规则</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li>
                            <code>@Test</code>：把一个方法标记为测试方法
                        <li>
                            <code>@Before</code>：每一个测试方法执行前自动调用一次
                        </li>
                        <li>
                            <code>@After</code>：每一个测试方法执行完自动调用一次
                        </li>
                        <li>
                            <code>@BeforeClass</code>：所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用<code>static</code>修饰
                        </li>
                        <li>
                            <code>@AfterClass</code>：所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用<code>static</code>修饰
                        </li>
                        <li>
                            <code>@Ignore</code>：暂不执行该测试方法
                        </li>
                    </ul>

                </div>
            </section>

            <section>
                <div class="down-1">
                    <h2>试验一下</h2>
                </div>
                <div class="down-1 row">
                    <div class="col-50">
                        <pre class="java tiny">
                        <code data-trim>
                                public class AnnotationTest {

                                    public AnnotationTest() {
                                        System.out.println("构造方法");
                                    }
                                
                                    @BeforeClass
                                    public static void setUpBeforeClass() {
                                        System.out.println("BeforeClass");
                                    }
                                
                                    @AfterClass
                                    public static void tearDownAfterClass() {
                                        System.out.println("AfterClass");
                                    }
                                
                                    @Before
                                    public void setUp() {
                                        System.out.println("Before");
                                    }
                                
                                    
                        </code>
                        
                    </pre>
                    </div>

                    <div class="col-50">
                        <pre class="java tiny">
                            <code data-trim>
                                    
                                    
                                        @After
                                        public void tearDown() {
                                            System.out.println("After");
                                        }
                                    
                                        @Test
                                        public void test1() {
                                            System.out.println("test1");
                                        }
                                    
                                        @Test
                                        public void test2() {
                                            System.out.println("test2");
                                        }
                                    
                                        @Ignore
                                        public void test3() {
                                            System.out.println("test3");
                                        }
                                    
                                    }
                            </code>
                            
                        </pre>
                    </div>
                </div>
                <div class="center small">

                    <ul>
                        <li>
                            <code>@BeforeClass</code>和<code>@AfterClass</code>在类被实例化前（构造方法执行前）就被调用了，而且只执行一次，通常用来初始化和关闭资源
                        </li>
                        <li>
                            <code>@Before</code>和<code>@After</code>和在每个<code>@Test</code>执行前后都会被执行一次
                        </li>
                        <li>
                            <code>@Test</code>标记一个方法为测试方法，被<code>@Ignore</code>标记的测试方法不会被执行
                        </li>
                        <li>
                            JUnit4为了保证每个测试方法都是单元测试，是独立的互不影响。所以每个测试方法执行前都会重新实例化测试类
                        </li>
                    </ul>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2><code>@Test</code>的属性</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li class="big down-5">
                            <code>excepted</code> 用来测试异常的
                        </li>
                        <li class="big down-5">
                            <code>timeout</code> 用来测试性能的
                        </li>
                    </ul>

                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2><code>expected</code></h2>
                </div>
                <div class="down-3">
                    <pre class="java">
                        <code data-trim>
                                @Test(expected = Exception.class)
                                public void testFactorialException() throws Exception {
                                    new Math().factorial(-1);
                                    fail("factorial参数为负数没有抛出异常");
                                }
                        </code>
                        
                    </pre>
                </div>

                <div class="down-1 small center">
                    测试方法会检查是否抛出Exception异常（当然也可以检测是否抛出其它异常）。如果抛出了异常那么测试通过（因为你的预期就是传进负数会抛出异常）。没有抛出异常则测试不通过执行fail("factorial参数为负数没有抛出异常")。
                </div>
            </section>

            <section>
                <div class="down-1">
                    <h2> <code>timeout</code></h2>
                </div>
                <div class="row">
                    <div class="down-1">
                        <pre class="java">
                            <code data-trim>
                                    public void sort(int[] arr) {
                                        //冒泡排序
                                        for (int i = 0; i < arr.length - 1; i++) { //控制比较轮数
                                            for (int j = 0; j < arr.length - i - 1; j++) { //控制每轮的两两比较次数
                                                if (arr[j] > arr[j + 1]) {
                                                    int temp = arr[j];
                                                    arr[j] = arr[j + 1];
                                                    arr[j + 1] = temp;
                                                }
                                            }
                                        }
                                    }
                                    @Test(timeout = 2000)
                                    public void testSort() throws Exception {
                                        int[] arr = new int[50000]; //数组长度为50000
                                        int arrLength = arr.length;
                                        //随机生成数组元素
                                        Random r = new Random();
                                        for (int i = 0; i < arrLength; i++) {
                                            arr[i] = r.nextInt(arrLength);
                                        }
                                        new Math().sort(arr);
                                    }
                            </code>
                            
                        </pre>
                    </div>
                </div>

            </section>


            <section>
                <div class="down-30 center larger">
                    为葫芦娃配上单元测试
                </div>
            </section>
        </div>
    </div>
</body>
</head>

</html>